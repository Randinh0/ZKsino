<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ZKsino - Flip Coin ZK</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }
        .container {
            max-width: 800px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }
        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 30px;
        }
        .section {
            margin-bottom: 25px;
            padding: 20px;
            border: 1px solid #e0e0e0;
            border-radius: 10px;
            background: #f9f9f9;
        }
        .section h3 {
            margin-top: 0;
            color: #555;
        }
        button {
            background: #667eea;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            margin: 5px;
            transition: background 0.3s;
        }
        button:hover {
            background: #5a6fd8;
        }
        button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        input, textarea {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 14px;
            margin: 5px 0;
        }
        .status {
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
        }
        .success { background: #d4edda; color: #155724; }
        .error { background: #f8d7da; color: #721c24; }
        .info { background: #d1ecf1; color: #0c5460; }
        .code {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 5px;
            padding: 10px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            overflow-x: auto;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>🎲 ZKsino - Flip Coin ZK</h1>
        
        <div class="section">
            <h3>🎯 Crear Apuesta</h3>
            <input type="number" id="betAmount" placeholder="Cantidad (ETH)" step="0.001" max="1.0" />
            <small style="color: #666;">💡 Límite: 0.001 - 1.0 ETH</small>
            <button id="createBetBtn">Crear Apuesta</button>
            <div id="betStatus"></div>
        </div>

        <div class="section">
            <h3>🎉 Resultado de la Apuesta</h3>
            <div id="proofStatus"></div>
            <div id="proofResult" class="code" style="display: none;"></div>
        </div>
    </div>

    <script src="./ethers.umd.min.js"></script>
    <script>
        // Configuración
        const CONTRACT_ADDRESS = '0xa513E6E4b8f2a923D98304ec87F64353C4D5C853'; // FlipCoinDualZK
        const ABI = [
            "function createBet(address _house, bytes32 _playerCommit) external payable",
            "function createBetWithCommits(address _house, bytes32 _playerCommit, bytes32 _houseCommit) external payable",
            "function houseCommit(uint256 _betId, bytes32 _houseCommit) external",
            "function settleBetWithDualZK(uint256 _betId, uint[2] calldata _pA, uint[2][2] calldata _pB, uint[2] calldata _pC, uint[4] calldata _pubSignals) external",
            "function getBetInfo(uint256 _betId) external view returns (address, address, uint256, bytes32, bytes32, uint256, bool, uint256)",
            "function setRandomIndexForTest(uint256 _betId, uint256 _index) external",
            "event BetCreated(uint256 indexed betId, address indexed player, address indexed house, uint256 amount)",
            "event HouseCommitted(uint256 indexed betId, address indexed house, bytes32 commit)",
            "event BetSettled(uint256 indexed betId, address indexed winner, uint256 payout, uint8 playerBit, uint8 houseBit, uint8 result)"
        ];

        let provider, signer, contract, currentBetId = 0;
        
        // Función para resetear estado
        function resetState() {
            currentBetId = 0;
            window.playerPreimage = null;
            window.housePreimage = null;
            window.playerCommit = null;
            window.houseCommit = null;
            window.currentBetId = null;
            window.currentBitIndex = null;
            window.currentProofData = null;
            
            // Limpiar displays
            document.getElementById('betStatus').innerHTML = '';
            document.getElementById('proofStatus').innerHTML = '';
            document.getElementById('proofResult').style.display = 'none';
            
            console.log('🔄 Estado reseteado');
        }
        
        // Función para escuchar eventos
        function setupEventListeners() {
            if (contract) {
                // Escuchar evento BetSettled
                contract.on('BetSettled', (betId, winner, payout, playerBit, houseBit, result, event) => {
                    console.log('🎉 Apuesta liquidada!', {
                        betId: betId.toString(),
                        winner,
                        payout: ethers.utils.formatEther(payout),
                        playerBit: playerBit.toString(),
                        houseBit: houseBit.toString(),
                        result: result.toString()
                    });
                    
                    // Mostrar notificación
                    const notification = document.createElement('div');
                    notification.className = 'status success';
                    notification.innerHTML = `🎉 Apuesta ${betId} liquidada! Ganador: ${winner}, Pago: ${ethers.utils.formatEther(payout)} ETH`;
                    document.body.appendChild(notification);
                    
                    // Remover notificación después de 5 segundos
                    setTimeout(() => {
                        if (notification.parentNode) {
                            notification.parentNode.removeChild(notification);
                        }
                    }, 5000);
                });
            }
        }

        // Función para conectar wallet automáticamente
        async function connectWallet() {
            try {
                console.log('🔍 Verificando MetaMask...');
                
                if (typeof window.ethereum === 'undefined') {
                    console.log('❌ MetaMask no detectado');
                    return false;
                }
                
                console.log('✅ MetaMask detectado');
                console.log('🔗 Solicitando cuentas...');
                
                const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
                console.log('✅ Cuentas obtenidas:', accounts);
                
                console.log('🌐 Creando provider...');
                provider = new ethers.providers.Web3Provider(window.ethereum);
                
                console.log('✍️ Obteniendo signer...');
                signer = provider.getSigner();
                
                console.log('📜 Creando contrato...');
                contract = new ethers.Contract(CONTRACT_ADDRESS, ABI, signer);
                
                console.log('🏠 Obteniendo dirección...');
                const address = await signer.getAddress();
                console.log('✅ Dirección obtenida:', address);
                
                // Verificar red
                const network = await provider.getNetwork();
                console.log('🌍 Red:', network);
                
                // También verificar directamente con eth_chainId
                const chainIdHex = await window.ethereum.request({ method: 'eth_chainId' });
                const chainIdDec = parseInt(chainIdHex, 16);
                console.log('🔗 Chain ID directo:', chainIdHex, '→', chainIdDec);
                
                if (network.chainId !== 1337 && chainIdDec !== 1337) {
                    console.log(`❌ Red incorrecta. Chain ID esperado: 1337, actual: ${network.chainId}`);
                    return false;
                }
                
                console.log('✅ Wallet conectado correctamente:', address);
                
                // Configurar listeners de eventos
                setupEventListeners();
                
                console.log('🎉 Conexión exitosa!');
                return true;
                
            } catch (error) {
                console.error('❌ Error conectando:', error);
                return false;
            }
        }

        // Crear apuesta
        document.getElementById('createBetBtn').onclick = async () => {
            try {
                // Verificar si hay wallet conectado, si no, conectar automáticamente
                if (!contract) {
                    console.log('🔄 Conectando wallet...');
                    
                    const connected = await connectWallet();
                    if (!connected) {
                        return; // No se pudo conectar
                    }
                }
                
                // Resetear estado automáticamente al crear nueva apuesta
                resetState();
                
                const betAmount = document.getElementById('betAmount').value;
                
                if (!betAmount) {
                    alert('Ingresa la cantidad de la apuesta');
                    return;
                }
                
                // Validar límites
                const amount = parseFloat(betAmount);
                if (amount < 0.001) {
                    alert('❌ Cantidad mínima: 0.001 ETH');
                    return;
                }
                if (amount > 1.0) {
                    alert('❌ Cantidad máxima: 1.0 ETH');
                    return;
                }

                // La casa es el propio contrato
                const houseAddress = CONTRACT_ADDRESS;

                // Generar preimagen aleatoria para el jugador
                const playerPreimage = generateRandomPreimage();
                
                // Obtener playerCommit real usando la API ZK
                document.getElementById('betStatus').innerHTML = 
                    `<div class="status info">🔄 Generando commit del jugador...</div>`;
                
                const commitResponse = await fetch('http://localhost:3001/calculate-commit', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ preimage: playerPreimage })
                });
                
                const commitData = await commitResponse.json();
                if (!commitData.success) {
                    throw new Error('Error calculando commit: ' + commitData.error);
                }
                
                const playerCommit = ethers.utils.hexZeroPad(ethers.BigNumber.from(commitData.commit).toHexString(), 32);
                
                // Generar preimagen aleatoria para la casa (para la prueba ZK posterior)
                const housePreimage = generateRandomPreimage();
                
                // Obtener houseCommit real usando la API ZK
                document.getElementById('betStatus').innerHTML = 
                    `<div class="status info">🔄 Generando commits...</div>`;
                
                const houseCommitResponse = await fetch('http://localhost:3001/calculate-commit', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ preimage: housePreimage })
                });
                
                const houseCommitData = await houseCommitResponse.json();
                if (!houseCommitData.success) {
                    throw new Error('Error calculando house commit: ' + houseCommitData.error);
                }
                
                const houseCommit = ethers.utils.hexZeroPad(ethers.BigNumber.from(houseCommitData.commit).toHexString(), 32);
                
                // Crear apuesta con ambos commits en UNA SOLA TRANSACCIÓN
                document.getElementById('betStatus').innerHTML = 
                    `<div class="status info">🔄 Creando apuesta con commits...</div>`;
                
                const tx = await contract.createBetWithCommits(houseAddress, playerCommit, houseCommit, {
                    value: ethers.utils.parseEther(betAmount)
                });
                
                const receipt = await tx.wait();
                
                // Obtener betId real del evento BetCreated
                const betCreatedEvent = receipt.events?.find(event => event.event === 'BetCreated');
                const betId = betCreatedEvent ? betCreatedEvent.args.betId.toNumber() : currentBetId;
                currentBetId = betId + 1;
                
                // Guardar datos para uso posterior
                window.playerPreimage = playerPreimage;
                window.playerCommit = playerCommit;
                window.housePreimage = housePreimage;
                window.houseCommit = houseCommit;
                window.currentBetId = betId;
                window.currentBitIndex = null; // Se generará automáticamente
                
                document.getElementById('betStatus').innerHTML = 
                    `<div class="status success">✅ ¡Apuesta creada! ID: ${betId} - Generando prueba ZK...</div>`;
                
                // GENERAR PRUEBA ZK AUTOMÁTICAMENTE
                document.getElementById('proofStatus').innerHTML = 
                    `<div class="status info">🔄 Generando prueba ZK y liquidando apuesta...</div>`;
                
                // Obtener información de la apuesta para conseguir el randomIndex
                const betInfo = await contract.getBetInfo(betId);
                const randomIndex = betInfo[5].toNumber(); // randomIndex es el índice 5
                
                if (randomIndex === 0) {
                    throw new Error('La apuesta no tiene randomIndex generado');
                }
                
                // Generar prueba usando las preimágenes reales y liquidar automáticamente
                const proofResponse = await fetch('http://localhost:3001/generate-proof', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        playerPreimage: playerPreimage,
                        housePreimage: housePreimage,
                        bitIndex: randomIndex,
                        betId: betId
                    })
                });
                
                const proofData = await proofResponse.json();
                
                if (!proofData.success) {
                    throw new Error(proofData.error);
                }
                
                // Mostrar resultado final
                const settlement = proofData.settlement;
                
                document.getElementById('proofResult').textContent = JSON.stringify({
                    betId: betId,
                    playerBit: proofData.playerBit,
                    houseBit: proofData.houseBit,
                    result: proofData.expectedResult,
                    settlement: settlement
                }, null, 2);
                document.getElementById('proofResult').style.display = 'block';
                
                if (settlement && settlement.settled) {
                    document.getElementById('betStatus').innerHTML = 
                        `<div class="status success">✅ ¡Apuesta creada exitosamente!</div>`;
                    
                    document.getElementById('proofStatus').innerHTML = 
                        `<div class="status success">🎉 ¡Apuesta liquidada automáticamente!<br/>
                         🏆 Ganador: ${settlement.winner}<br/>
                         🎲 Resultado: ${settlement.result === '1' ? '¡Ganaste!' : 'Perdiste'}<br/>
                         💰 Apuesta: ${betAmount} ETH<br/>
                         📝 TX: <a href="#" style="color: #007bff;">${settlement.txHash}</a></div>`;
                } else {
                    document.getElementById('proofStatus').innerHTML = 
                        `<div class="status error">❌ Error en la liquidación automática</div>`;
                }
            } catch (error) {
                console.error('Error creando apuesta:', error);
                document.getElementById('betStatus').innerHTML = 
                    `<div class="status error">❌ Error: ${error.message}</div>`;
            }
        };





        // Función para generar preimagen aleatoria
        function generateRandomPreimage() {
            const preimage = [];
            for (let i = 0; i < 16; i++) {
                preimage.push(Math.floor(Math.random() * 4294967296));
            }
            return preimage;
        }

        // Función para calcular hash Poseidon (simplificado para testing)
        async function calculatePoseidonHash(preimage) {
            // Por ahora, usamos un hash simple para testing
            // En producción, esto usaría circomlibjs
            return ethers.utils.keccak256(ethers.utils.defaultAbiCoder.encode(['uint256[16]'], [preimage]));
        }
        
        // Conectar automáticamente al cargar la página
        window.addEventListener('load', async () => {
            console.log('🚀 Página cargada, conectando wallet automáticamente...');
            await connectWallet();
        });
    </script>
</body>
</html>