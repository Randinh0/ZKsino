<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ZKsino - Flip Coin ZK</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }
        .container {
            max-width: 800px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }
        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 30px;
        }
        .section {
            margin-bottom: 25px;
            padding: 20px;
            border: 1px solid #e0e0e0;
            border-radius: 10px;
            background: #f9f9f9;
        }
        .section h3 {
            margin-top: 0;
            color: #555;
        }
        button {
            background: #667eea;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            margin: 5px;
            transition: background 0.3s;
        }
        button:hover {
            background: #5a6fd8;
        }
        button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        input, textarea {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 14px;
            margin: 5px 0;
        }
        .status {
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
        }
        .success { background: #d4edda; color: #155724; }
        .error { background: #f8d7da; color: #721c24; }
        .info { background: #d1ecf1; color: #0c5460; }
        .code {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 5px;
            padding: 10px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            overflow-x: auto;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üé≤ ZKsino - Flip Coin ZK</h1>
        
        <div class="section">
            <h3>üéØ Crear Apuesta</h3>
            <input type="number" id="betAmount" placeholder="Cantidad (ETH)" step="0.001" max="1.0" />
            <small style="color: #666;">üí° L√≠mite: 0.001 - 1.0 ETH</small>
            <button id="createBetBtn">Crear Apuesta</button>
            <div id="betStatus"></div>
        </div>

        <div class="section">
            <h3>üéâ Resultado de la Apuesta</h3>
            <div id="proofStatus"></div>
            <div id="proofResult" class="code" style="display: none;"></div>
        </div>
    </div>

    <script src="./ethers.umd.min.js"></script>
    <script>
        // Configuraci√≥n
        const CONTRACT_ADDRESS = '0xa513E6E4b8f2a923D98304ec87F64353C4D5C853'; // FlipCoinDualZK
        const ABI = [
            "function createBet(address _house, bytes32 _playerCommit) external payable",
            "function createBetWithCommits(address _house, bytes32 _playerCommit, bytes32 _houseCommit) external payable",
            "function houseCommit(uint256 _betId, bytes32 _houseCommit) external",
            "function settleBetWithDualZK(uint256 _betId, uint[2] calldata _pA, uint[2][2] calldata _pB, uint[2] calldata _pC, uint[4] calldata _pubSignals) external",
            "function getBetInfo(uint256 _betId) external view returns (address, address, uint256, bytes32, bytes32, uint256, bool, uint256)",
            "function setRandomIndexForTest(uint256 _betId, uint256 _index) external",
            "event BetCreated(uint256 indexed betId, address indexed player, address indexed house, uint256 amount)",
            "event HouseCommitted(uint256 indexed betId, address indexed house, bytes32 commit)",
            "event BetSettled(uint256 indexed betId, address indexed winner, uint256 payout, uint8 playerBit, uint8 houseBit, uint8 result)"
        ];

        let provider, signer, contract, currentBetId = 0;
        
        // Funci√≥n para resetear estado
        function resetState() {
            currentBetId = 0;
            window.playerPreimage = null;
            window.housePreimage = null;
            window.playerCommit = null;
            window.houseCommit = null;
            window.currentBetId = null;
            window.currentBitIndex = null;
            window.currentProofData = null;
            
            // Limpiar displays
            document.getElementById('betStatus').innerHTML = '';
            document.getElementById('proofStatus').innerHTML = '';
            document.getElementById('proofResult').style.display = 'none';
            
            console.log('üîÑ Estado reseteado');
        }
        
        // Funci√≥n para escuchar eventos
        function setupEventListeners() {
            if (contract) {
                // Escuchar evento BetSettled
                contract.on('BetSettled', (betId, winner, payout, playerBit, houseBit, result, event) => {
                    console.log('üéâ Apuesta liquidada!', {
                        betId: betId.toString(),
                        winner,
                        payout: ethers.utils.formatEther(payout),
                        playerBit: playerBit.toString(),
                        houseBit: houseBit.toString(),
                        result: result.toString()
                    });
                    
                    // Mostrar notificaci√≥n
                    const notification = document.createElement('div');
                    notification.className = 'status success';
                    notification.innerHTML = `üéâ Apuesta ${betId} liquidada! Ganador: ${winner}, Pago: ${ethers.utils.formatEther(payout)} ETH`;
                    document.body.appendChild(notification);
                    
                    // Remover notificaci√≥n despu√©s de 5 segundos
                    setTimeout(() => {
                        if (notification.parentNode) {
                            notification.parentNode.removeChild(notification);
                        }
                    }, 5000);
                });
            }
        }

        // Funci√≥n para conectar wallet autom√°ticamente
        async function connectWallet() {
            try {
                console.log('üîç Verificando MetaMask...');
                
                if (typeof window.ethereum === 'undefined') {
                    console.log('‚ùå MetaMask no detectado');
                    return false;
                }
                
                console.log('‚úÖ MetaMask detectado');
                console.log('üîó Solicitando cuentas...');
                
                const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
                console.log('‚úÖ Cuentas obtenidas:', accounts);
                
                console.log('üåê Creando provider...');
                provider = new ethers.providers.Web3Provider(window.ethereum);
                
                console.log('‚úçÔ∏è Obteniendo signer...');
                signer = provider.getSigner();
                
                console.log('üìú Creando contrato...');
                contract = new ethers.Contract(CONTRACT_ADDRESS, ABI, signer);
                
                console.log('üè† Obteniendo direcci√≥n...');
                const address = await signer.getAddress();
                console.log('‚úÖ Direcci√≥n obtenida:', address);
                
                // Verificar red
                const network = await provider.getNetwork();
                console.log('üåç Red:', network);
                
                // Tambi√©n verificar directamente con eth_chainId
                const chainIdHex = await window.ethereum.request({ method: 'eth_chainId' });
                const chainIdDec = parseInt(chainIdHex, 16);
                console.log('üîó Chain ID directo:', chainIdHex, '‚Üí', chainIdDec);
                
                if (network.chainId !== 1337 && chainIdDec !== 1337) {
                    console.log(`‚ùå Red incorrecta. Chain ID esperado: 1337, actual: ${network.chainId}`);
                    return false;
                }
                
                console.log('‚úÖ Wallet conectado correctamente:', address);
                
                // Configurar listeners de eventos
                setupEventListeners();
                
                console.log('üéâ Conexi√≥n exitosa!');
                return true;
                
            } catch (error) {
                console.error('‚ùå Error conectando:', error);
                return false;
            }
        }

        // Crear apuesta
        document.getElementById('createBetBtn').onclick = async () => {
            try {
                // Verificar si hay wallet conectado, si no, conectar autom√°ticamente
                if (!contract) {
                    console.log('üîÑ Conectando wallet...');
                    
                    const connected = await connectWallet();
                    if (!connected) {
                        return; // No se pudo conectar
                    }
                }
                
                // Resetear estado autom√°ticamente al crear nueva apuesta
                resetState();
                
                const betAmount = document.getElementById('betAmount').value;
                
                if (!betAmount) {
                    alert('Ingresa la cantidad de la apuesta');
                    return;
                }
                
                // Validar l√≠mites
                const amount = parseFloat(betAmount);
                if (amount < 0.001) {
                    alert('‚ùå Cantidad m√≠nima: 0.001 ETH');
                    return;
                }
                if (amount > 1.0) {
                    alert('‚ùå Cantidad m√°xima: 1.0 ETH');
                    return;
                }

                // La casa es el propio contrato
                const houseAddress = CONTRACT_ADDRESS;

                // Generar preimagen aleatoria para el jugador
                const playerPreimage = generateRandomPreimage();
                
                // Obtener playerCommit real usando la API ZK
                document.getElementById('betStatus').innerHTML = 
                    `<div class="status info">üîÑ Generando commit del jugador...</div>`;
                
                const commitResponse = await fetch('http://localhost:3001/calculate-commit', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ preimage: playerPreimage })
                });
                
                const commitData = await commitResponse.json();
                if (!commitData.success) {
                    throw new Error('Error calculando commit: ' + commitData.error);
                }
                
                const playerCommit = ethers.utils.hexZeroPad(ethers.BigNumber.from(commitData.commit).toHexString(), 32);
                
                // Generar preimagen aleatoria para la casa (para la prueba ZK posterior)
                const housePreimage = generateRandomPreimage();
                
                // Obtener houseCommit real usando la API ZK
                document.getElementById('betStatus').innerHTML = 
                    `<div class="status info">üîÑ Generando commits...</div>`;
                
                const houseCommitResponse = await fetch('http://localhost:3001/calculate-commit', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ preimage: housePreimage })
                });
                
                const houseCommitData = await houseCommitResponse.json();
                if (!houseCommitData.success) {
                    throw new Error('Error calculando house commit: ' + houseCommitData.error);
                }
                
                const houseCommit = ethers.utils.hexZeroPad(ethers.BigNumber.from(houseCommitData.commit).toHexString(), 32);
                
                // Crear apuesta con ambos commits en UNA SOLA TRANSACCI√ìN
                document.getElementById('betStatus').innerHTML = 
                    `<div class="status info">üîÑ Creando apuesta con commits...</div>`;
                
                const tx = await contract.createBetWithCommits(houseAddress, playerCommit, houseCommit, {
                    value: ethers.utils.parseEther(betAmount)
                });
                
                const receipt = await tx.wait();
                
                // Obtener betId real del evento BetCreated
                const betCreatedEvent = receipt.events?.find(event => event.event === 'BetCreated');
                const betId = betCreatedEvent ? betCreatedEvent.args.betId.toNumber() : currentBetId;
                currentBetId = betId + 1;
                
                // Guardar datos para uso posterior
                window.playerPreimage = playerPreimage;
                window.playerCommit = playerCommit;
                window.housePreimage = housePreimage;
                window.houseCommit = houseCommit;
                window.currentBetId = betId;
                window.currentBitIndex = null; // Se generar√° autom√°ticamente
                
                document.getElementById('betStatus').innerHTML = 
                    `<div class="status success">‚úÖ ¬°Apuesta creada! ID: ${betId} - Generando prueba ZK...</div>`;
                
                // GENERAR PRUEBA ZK AUTOM√ÅTICAMENTE
                document.getElementById('proofStatus').innerHTML = 
                    `<div class="status info">üîÑ Generando prueba ZK y liquidando apuesta...</div>`;
                
                // Obtener informaci√≥n de la apuesta para conseguir el randomIndex
                const betInfo = await contract.getBetInfo(betId);
                const randomIndex = betInfo[5].toNumber(); // randomIndex es el √≠ndice 5
                
                if (randomIndex === 0) {
                    throw new Error('La apuesta no tiene randomIndex generado');
                }
                
                // Generar prueba usando las preim√°genes reales y liquidar autom√°ticamente
                const proofResponse = await fetch('http://localhost:3001/generate-proof', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        playerPreimage: playerPreimage,
                        housePreimage: housePreimage,
                        bitIndex: randomIndex,
                        betId: betId
                    })
                });
                
                const proofData = await proofResponse.json();
                
                if (!proofData.success) {
                    throw new Error(proofData.error);
                }
                
                // Mostrar resultado final
                const settlement = proofData.settlement;
                
                document.getElementById('proofResult').textContent = JSON.stringify({
                    betId: betId,
                    playerBit: proofData.playerBit,
                    houseBit: proofData.houseBit,
                    result: proofData.expectedResult,
                    settlement: settlement
                }, null, 2);
                document.getElementById('proofResult').style.display = 'block';
                
                if (settlement && settlement.settled) {
                    document.getElementById('betStatus').innerHTML = 
                        `<div class="status success">‚úÖ ¬°Apuesta creada exitosamente!</div>`;
                    
                    document.getElementById('proofStatus').innerHTML = 
                        `<div class="status success">üéâ ¬°Apuesta liquidada autom√°ticamente!<br/>
                         üèÜ Ganador: ${settlement.winner}<br/>
                         üé≤ Resultado: ${settlement.result === '1' ? '¬°Ganaste!' : 'Perdiste'}<br/>
                         üí∞ Apuesta: ${betAmount} ETH<br/>
                         üìù TX: <a href="#" style="color: #007bff;">${settlement.txHash}</a></div>`;
                } else {
                    document.getElementById('proofStatus').innerHTML = 
                        `<div class="status error">‚ùå Error en la liquidaci√≥n autom√°tica</div>`;
                }
            } catch (error) {
                console.error('Error creando apuesta:', error);
                document.getElementById('betStatus').innerHTML = 
                    `<div class="status error">‚ùå Error: ${error.message}</div>`;
            }
        };





        // Funci√≥n para generar preimagen aleatoria
        function generateRandomPreimage() {
            const preimage = [];
            for (let i = 0; i < 16; i++) {
                preimage.push(Math.floor(Math.random() * 4294967296));
            }
            return preimage;
        }

        // Funci√≥n para calcular hash Poseidon (simplificado para testing)
        async function calculatePoseidonHash(preimage) {
            // Por ahora, usamos un hash simple para testing
            // En producci√≥n, esto usar√≠a circomlibjs
            return ethers.utils.keccak256(ethers.utils.defaultAbiCoder.encode(['uint256[16]'], [preimage]));
        }
        
        // Conectar autom√°ticamente al cargar la p√°gina
        window.addEventListener('load', async () => {
            console.log('üöÄ P√°gina cargada, conectando wallet autom√°ticamente...');
            await connectWallet();
        });
    </script>
</body>
</html>